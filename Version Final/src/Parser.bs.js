// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Ast$Nqcc = require("./Ast.bs.js");
var Token$Nqcc = require("./Token.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function parse_factor(tokenList) {
  if (tokenList) {
    var remainingTokens = tokenList[1];
    var token = tokenList[0];
    if (Token$Nqcc.identificador(token) === "Negation" || Token$Nqcc.identificador(token) === "Bitwise" || Token$Nqcc.identificador(token) === "LogNeg") {
      var match = parse_factor(remainingTokens);
      var remainingTokens$1 = match[1];
      var fac = match[0];
      if (Ast$Nqcc.identi_factor(fac) === true) {
        return /* tuple */[
                /* UnOp */Block.__(0, [
                    token,
                    fac
                  ]),
                remainingTokens$1
              ];
      } else {
        return /* tuple */[
                /* Err_fac */Block.__(1, ["Error, falta una constante u operador unario"]),
                remainingTokens$1
              ];
      }
    } else if (Token$Nqcc.identificador(token) === "Constant") {
      var number = Caml_format.caml_int_of_string(Token$Nqcc.extrac(token));
      return /* tuple */[
              /* Const */Block.__(2, [number]),
              remainingTokens
            ];
    } else {
      return /* tuple */[
              /* Err_fac */Block.__(1, ["Error, falta una constante u operador unario"]),
              tokenList
            ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "Parser.re",
            2,
            8
          ]
        ];
  }
}

function parse_termino(tokenList) {
  var match = parse_factor(tokenList);
  var tokenList$1 = match[1];
  var fac1 = match[0];
  if (Ast$Nqcc.identi_factor(fac1) === true) {
    if (tokenList$1) {
      var token = tokenList$1[0];
      if (Token$Nqcc.identificador(token) === "Multiplication" || Token$Nqcc.identificador(token) === "Division") {
        var match$1 = parse_factor(tokenList$1[1]);
        var r = match$1[1];
        var fac2 = match$1[0];
        if (Ast$Nqcc.identi_factor(fac2) === true) {
          return /* tuple */[
                  /* BinOp */Block.__(2, [
                      token,
                      fac1,
                      fac2
                    ]),
                  r
                ];
        } else {
          return /* tuple */[
                  /* Err_ter */Block.__(1, [Ast$Nqcc.ext_fac_err(fac1)]),
                  r
                ];
        }
      } else {
        return /* tuple */[
                /* Ter */Block.__(0, [fac1]),
                tokenList$1
              ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.match_failure,
            /* tuple */[
              "Parser.re",
              24,
              12
            ]
          ];
    }
  } else {
    return /* tuple */[
            /* Err_ter */Block.__(1, [Ast$Nqcc.ext_fac_err(fac1)]),
            tokenList$1
          ];
  }
}

function parse_exp(tokenList) {
  var match = parse_termino(tokenList);
  var tokenList$1 = match[1];
  var ter1 = match[0];
  if (Ast$Nqcc.identi_termino(ter1) === true) {
    if (tokenList$1) {
      var token = tokenList$1[0];
      if (Token$Nqcc.identificador(token) === "Addition" || Token$Nqcc.identificador(token) === "Negation") {
        var match$1 = parse_termino(tokenList$1[1]);
        var r = match$1[1];
        var ter2 = match$1[0];
        if (Ast$Nqcc.identi_termino(ter2) === true) {
          return /* tuple */[
                  /* BinOp */Block.__(2, [
                      token,
                      ter1,
                      ter2
                    ]),
                  r
                ];
        } else {
          return /* tuple */[
                  /* Err_exp */Block.__(1, [Ast$Nqcc.ext_ter_err(ter2)]),
                  r
                ];
        }
      } else {
        return /* tuple */[
                /* Expr */Block.__(0, [ter1]),
                tokenList$1
              ];
      }
    } else {
      throw [
            Caml_builtin_exceptions.match_failure,
            /* tuple */[
              "Parser.re",
              45,
              12
            ]
          ];
    }
  } else {
    return /* tuple */[
            /* Err_exp */Block.__(1, [Ast$Nqcc.ext_ter_err(ter1)]),
            tokenList$1
          ];
  }
}

function parse_statement(tokenList) {
  if (tokenList) {
    var remainingTokens = tokenList[1];
    var token = tokenList[0];
    if (Token$Nqcc.identificador(token) === "ReturnKeyword") {
      var $$var = Token$Nqcc.identificador(token);
      var match = parse_exp(remainingTokens);
      var remainingTokens$1 = match[1];
      var exp = match[0];
      if (Ast$Nqcc.identi_exp(exp) === true) {
        if (remainingTokens$1) {
          var remainingTokens$2 = remainingTokens$1[1];
          if (Token$Nqcc.identificador(remainingTokens$1[0]) === "Semicolon") {
            return /* tuple */[
                    /* Assign */Block.__(0, [
                        $$var,
                        exp
                      ]),
                    remainingTokens$2
                  ];
          } else {
            return /* tuple */[
                    /* Err_state */Block.__(2, ["Error, falta ;"]),
                    remainingTokens$2
                  ];
          }
        } else {
          throw [
                Caml_builtin_exceptions.match_failure,
                /* tuple */[
                  "Parser.re",
                  68,
                  16
                ]
              ];
        }
      } else {
        return /* tuple */[
                /* Err_state */Block.__(2, [Ast$Nqcc.ext_exp_err(exp)]),
                remainingTokens$1
              ];
      }
    } else {
      return /* tuple */[
              /* Err_state */Block.__(2, ["Error, falta return"]),
              remainingTokens
            ];
    }
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "Parser.re",
            63,
            8
          ]
        ];
  }
}

function parse_function(tokenList) {
  if (tokenList) {
    if (Token$Nqcc.identificador(tokenList[0]) === "IntKeyword") {
      var remainingTokens = tokenList[1];
      if (remainingTokens) {
        var token = remainingTokens[0];
        if (Token$Nqcc.identificador(token) === "Id") {
          var remainingTokens$1 = remainingTokens[1];
          var idName = Token$Nqcc.extrac(token);
          if (remainingTokens$1) {
            if (Token$Nqcc.identificador(remainingTokens$1[0]) === "OpenParen") {
              var remainingTokens$2 = remainingTokens$1[1];
              if (remainingTokens$2) {
                if (Token$Nqcc.identificador(remainingTokens$2[0]) === "CloseParen") {
                  var remainingTokens$3 = remainingTokens$2[1];
                  if (remainingTokens$3) {
                    if (Token$Nqcc.identificador(remainingTokens$3[0]) === "OpenBrace") {
                      var match = parse_statement(remainingTokens$3[1]);
                      var remainingTokens$4 = match[1];
                      var $$return = match[0];
                      if (Ast$Nqcc.identi_statement($$return) === true) {
                        if (remainingTokens$4) {
                          if (Token$Nqcc.identificador(remainingTokens$4[0]) === "CloseBrace") {
                            return /* Fun */Block.__(1, [
                                      idName,
                                      $$return
                                    ]);
                          } else {
                            return /* Err_fun */Block.__(0, ["Error, falta }"]);
                          }
                        } else {
                          throw [
                                Caml_builtin_exceptions.match_failure,
                                /* tuple */[
                                  "Parser.re",
                                  96,
                                  32
                                ]
                              ];
                        }
                      } else {
                        return /* Err_fun */Block.__(0, [Ast$Nqcc.ext_state_err($$return)]);
                      }
                    } else {
                      return /* Err_fun */Block.__(0, ["Error, falta {"]);
                    }
                  } else {
                    throw [
                          Caml_builtin_exceptions.match_failure,
                          /* tuple */[
                            "Parser.re",
                            92,
                            24
                          ]
                        ];
                  }
                } else {
                  return /* Err_fun */Block.__(0, ["Error, falta )"]);
                }
              } else {
                throw [
                      Caml_builtin_exceptions.match_failure,
                      /* tuple */[
                        "Parser.re",
                        90,
                        20
                      ]
                    ];
              }
            } else {
              return /* Err_fun */Block.__(0, ["Error, falta ("]);
            }
          } else {
            throw [
                  Caml_builtin_exceptions.match_failure,
                  /* tuple */[
                    "Parser.re",
                    88,
                    16
                  ]
                ];
          }
        } else {
          return /* Err_fun */Block.__(0, ["Error, falta identificador"]);
        }
      } else {
        throw [
              Caml_builtin_exceptions.match_failure,
              /* tuple */[
                "Parser.re",
                85,
                12
              ]
            ];
      }
    } else {
      return /* Err_fun */Block.__(0, ["Error, falta int"]);
    }
  } else {
    throw [
          Caml_builtin_exceptions.match_failure,
          /* tuple */[
            "Parser.re",
            83,
            8
          ]
        ];
  }
}

function parse_program(tokenList) {
  var func_decl = parse_function(tokenList);
  if (Ast$Nqcc.identi_fun_decl(func_decl) === true) {
    return /* Prog */Block.__(0, [func_decl]);
  } else {
    console.log(Ast$Nqcc.ext_fun_err(func_decl));
    return /* Err_prog */Block.__(1, ["Error en el parser"]);
  }
}

exports.parse_factor = parse_factor;
exports.parse_termino = parse_termino;
exports.parse_exp = parse_exp;
exports.parse_statement = parse_statement;
exports.parse_function = parse_function;
exports.parse_program = parse_program;
/* No side effect */
